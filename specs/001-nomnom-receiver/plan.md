# Implementation Plan: NomNom Knowledge Receiver

**Branch**: `001-nomnom-receiver` | **Date**: 2026-02-24 | **Spec**: [spec.md](./spec.md)

## Summary

Build the server-side component of NomNom: a Python HTTP receiver that accepts web page content submissions from the Tampermonkey userscript, persists them to SQLite, and performs server-side YouTube content extraction via yt-dlp and youtube-transcript-api. Packaged as a Docker image published to GHCR, deployed via Docker Compose.

---

## Technical Context

**Language/Version**: Python 3.12
**Primary Dependencies**: FastAPI, Uvicorn, Pydantic, yt-dlp, youtube-transcript-api
**Storage**: SQLite (WAL mode, per-thread connections, versioned SQL migrations)
**Testing**: pytest, pytest-asyncio, httpx (async test client for FastAPI)
**Target Platform**: Linux container (amd64 + arm64), homelab Docker host
**Project Type**: Web service (single-endpoint HTTP receiver)
**Performance Goals**: < 2s response for standard submissions; YouTube enrichment is async (non-blocking)
**Constraints**: No auth required; CORS open to all origins; SQLite persisted via named Docker volume
**Scale/Scope**: Single user, local network; occasional concurrent submissions from multiple browser tabs

---

## Constitution Check

The constitution file is a blank template — no project-specific gates are defined. No violations to evaluate.

---

## Project Structure

### Documentation (this feature)

```text
specs/001-nomnom-receiver/
├── plan.md                    # This file
├── research.md                # Phase 0 output
├── data-model.md              # Phase 1 output
├── quickstart.md              # Phase 1 output
├── contracts/
│   └── ingest-endpoint.md     # Phase 1 output
└── tasks.md                   # Phase 2 output (/speckit.tasks)
```

### Source Code (repository root)

```text
nomnom/
├── __init__.py
├── main.py                    # FastAPI app factory + Uvicorn entrypoint
├── config.py                  # Settings via environment variables (pydantic-settings)
├── models/
│   ├── __init__.py
│   └── submission.py          # Domain dataclasses: Submission, EnrichmentJob
├── schemas/
│   ├── __init__.py
│   └── ingest.py              # Pydantic request/response models
├── repositories/
│   ├── __init__.py
│   ├── base.py                # Abstract base repository
│   └── submission_repository.py
├── services/
│   ├── __init__.py
│   ├── ingestion_service.py   # Orchestrates ingest flow; calls repository
│   └── youtube_service.py     # yt-dlp + youtube-transcript-api integration
├── db/
│   ├── __init__.py
│   ├── connection.py          # SQLite connection factory (WAL, timeout)
│   └── migrations/
│       └── 001_init.sql
└── api/
    ├── __init__.py
    └── routes.py              # POST / and GET /health handlers

tests/
├── conftest.py                # Fixtures: test DB, test client
├── unit/
│   ├── test_ingestion_service.py
│   └── test_youtube_service.py
└── integration/
    └── test_api.py            # End-to-end POST / and GET /health

Dockerfile
docker-compose.yml
.github/
└── workflows/
    └── docker-publish.yml
requirements.txt
requirements-dev.txt
.env.example
README.md
```

**Structure Decision**: Single project layout. The `nomnom/` package contains all application code organized into four layers: API (routes), Services (business logic), Repositories (data access), and Models (domain objects). This matches the Repository pattern chosen in research.

---

## Phase 0: Research

**Status**: Complete — see [research.md](./research.md)

| Question           | Decision                                                     |
| ------------------ | ------------------------------------------------------------ |
| Web framework      | FastAPI + Uvicorn                                            |
| YouTube extraction | yt-dlp (metadata) + youtube-transcript-api (transcript text) |
| SQLite threading   | WAL mode + per-thread connections                            |
| OOP pattern        | Repository + Service layers                                  |
| Migrations         | Versioned SQL scripts                                        |
| Docker base        | python:3.12-slim, multi-stage build                          |
| Registry           | GHCR via GitHub Actions                                      |

---

## Phase 1: Design

**Status**: Complete

- [data-model.md](./data-model.md) — Submission and EnrichmentJob entities, SQL schema, migration scripts
- [contracts/ingest-endpoint.md](./contracts/ingest-endpoint.md) — Full HTTP contract: request payloads, responses, CORS, upsert semantics
- [quickstart.md](./quickstart.md) — Docker Compose and local dev setup

---

## Phase 2: Implementation Sequence

_Tasks file generated by `/speckit.tasks`._

### Layer build order

1. **DB layer** — `db/connection.py` + `db/migrations/001_init.sql` + migration runner
2. **Domain models** — `models/submission.py` (pure dataclasses, no I/O)
3. **Schemas** — `schemas/ingest.py` (Pydantic, matches contract payload)
4. **Repository** — `repositories/submission_repository.py` (upsert, enrichment job CRUD)
5. **YouTube service** — `services/youtube_service.py` (yt-dlp + youtube-transcript-api)
6. **Ingestion service** — `services/ingestion_service.py` (orchestrate: validate → upsert → enqueue enrichment)
7. **API routes** — `api/routes.py` (POST /, GET /health, CORS middleware)
8. **App entrypoint** — `nomnom/main.py` (FastAPI app factory, startup event for migrations)
9. **Tests** — unit (services mocked) + integration (test client against in-memory SQLite)
10. **Dockerfile** — multi-stage, non-root user, health check
11. **docker-compose.yml** — named volume, port 3002, restart policy, healthcheck
12. **GitHub Actions** — `.github/workflows/docker-publish.yml`, GHCR push on main

### Key design decisions to carry into implementation

- YouTube enrichment runs as a **background task** (`asyncio.create_task` via FastAPI's `BackgroundTasks`) — the endpoint returns `200` immediately and enrichment proceeds asynchronously.
- The `IngestionService` determines content type from `metadata.type` and dispatches to YouTube enrichment path or standard path accordingly.
- `SubmissionRepository.upsert()` uses `INSERT OR REPLACE` (or `INSERT ... ON CONFLICT DO UPDATE`) — it preserves `ingested_at` and refreshes `updated_at`.
- Config is loaded once at startup from environment variables via `pydantic-settings`. DB path and port are the two primary settings.
- The migration runner checks `db/migrations/` for `.sql` files on startup and applies any not yet recorded in a `_migrations` tracking table.
